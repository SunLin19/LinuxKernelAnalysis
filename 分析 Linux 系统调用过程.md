##分析 Linux 系统调用过程

###1.系统调用概述
现代操作系统为了保证安全性，通常把运行状态分为用户态和内核态，并规定，只有特权指令才能在内核态运行，用户程序只能在用户态下运行。那么，假如用户程序需要访问系统的核心功能，怎么办？没错儿，就是通过系统调用。

简单来说，系统调用就是把应用程序的请求传递给内核，调用相应的内核函数来处理请求，然后再将处理结果返回给应用程序。

本次实验选用 `Linux` 操作系统 2 号系统调用，`fork` 函数，通过对比嵌入式汇编编程和系统函数编程，深入理解和分析系统调用的过程。

###2.fork 函数
我们来实现一个简单的系统调用函数：  

![](http://upload-images.jianshu.io/upload_images/1627862-b4c84bc056d43133.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

###3.嵌入式汇编
首先，我们来看看 `C` 语言嵌入式汇编一般格式：

```
__asm__ (
    汇编语句；
    输出部分；
    输入部分；
    破坏描述部分；
);
```  
然后，再来分析我们的嵌入式汇编代码：

![](http://upload-images.jianshu.io/upload_images/1627862-8a0075f0c0784251.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

`volatile` 关键字表示禁止编译器优化，然后把 `ebx` 寄存器清零，把第 2 号系统调用赋给 `eax` 寄存器，然后再调用 `0x80` 号系统中断，最后把 eax 的值赋给第 0 个变量，即下面的 `fpid` 变量。

![](http://upload-images.jianshu.io/upload_images/1627862-92ff94ccb6b6dedb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

最后，运行这段函数，并与使用 C 语言实现的系统调用进行对比。如上图所示，二者运行结果完全相同。

###4.总结
操作系统作为管理硬件资源和为应用程序运行环境，为了达到良好的兼容性和平衡性，内核提供了一系列的定制化的函数，使得开发者和用户程序完全不需要了解复杂的硬件体系结构，屏蔽了底层交互细节，听起来是不是遵循了某种软件设计模式呢？这个简单的问题就留给读者思考咯。
